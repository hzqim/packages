diff -ru a/Makefile b/Makefile
--- a/Makefile	2018-10-19 02:21:55.000000000 +0800
+++ b/Makefile	2018-10-19 23:07:42.143009614 +0800
@@ -65,6 +65,8 @@
 nettle_cflags = `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_DNSSEC $(PKG_CONFIG) --cflags nettle hogweed`
 nettle_libs =   `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_DNSSEC $(PKG_CONFIG) --libs nettle hogweed`
 gmp_libs =      `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_DNSSEC NO_GMP --copy -lgmp`
+regex_cflags =  `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_REGEX $(PKG_CONFIG) --cflags libpcre`
+regex_libs =    `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_REGEX $(PKG_CONFIG) --libs libpcre`
 sunos_libs =    `if uname | grep SunOS >/dev/null 2>&1; then echo -lsocket -lnsl -lposix4; fi`
 version =     -DVERSION='\"`$(top)/bld/get-version $(top)`\"'
 
@@ -85,8 +87,8 @@
 all : $(BUILDDIR)
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
- build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags)" \
- build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs)" \
+ build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(regex_cflags)" \
+ build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs) $(regex_libs)" \
  -f $(top)/Makefile dnsmasq 
 
 mostly_clean :
@@ -110,8 +112,8 @@
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
  i18n=-DLOCALEDIR=\'\"$(LOCALEDIR)\"\' \
- build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags)" \
- build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs)"  \
+ build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(regex_cflags)" \
+ build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(regex_libs)"  \
  -f $(top)/Makefile dnsmasq
 	for f in `cd $(PO); echo *.po`; do \
 		cd $(top) && cd $(BUILDDIR) && $(MAKE) top="$(top)" -f $(top)/Makefile $${f%.po}.mo; \
diff -ru a/src/config.h b/src/config.h
--- a/src/config.h	2018-10-19 02:21:55.000000000 +0800
+++ b/src/config.h	2018-10-19 23:11:17.345466172 +0800
@@ -172,6 +172,7 @@
 #define HAVE_IPSET 
 #define HAVE_LOOP
 #define HAVE_DUMPFILE
+#define HAVE_REGEX
 
 /* Build options which require external libraries.
    
@@ -407,6 +408,10 @@
 "no-"
 #endif
 "i18n "
+#ifndef HAVE_REGEX
+"no-"
+#endif
+"regex "
 #if defined(HAVE_LIBIDN2)
 "IDN2 "
 #else
diff -ru a/src/dnsmasq.h b/src/dnsmasq.h
--- a/src/dnsmasq.h	2018-10-19 22:54:58.388259000 +0800
+++ b/src/dnsmasq.h	2018-10-19 23:15:29.268718647 +0800
@@ -156,6 +156,10 @@
 #  include <nettle/nettle-meta.h>
 #endif
 
+#ifdef HAVE_REGEX
+#include <pcre.h>
+#endif
+
 /* daemon is function in the C library.... */
 #define daemon dnsmasq_daemon
 
@@ -524,6 +528,7 @@
 #define SERV_LOOP           8192  /* server causes forwarding loop */
 #define SERV_DO_DNSSEC     16384  /* Validate DNSSEC when using this server */
 #define SERV_GOT_TCP       32768  /* Got some data from the TCP connection */
+#define SERV_IS_REGEX      65536  /* server entry is a regex */
 
 struct serverfd {
   int fd;
@@ -549,7 +554,11 @@
 #ifdef HAVE_LOOP
   u32 uid;
 #endif
-  struct server *next; 
+  struct server *next;
+#ifdef HAVE_REGEX
+  pcre *regex;
+  pcre_extra *pextra;
+#endif 
 };
 
 struct ipsets {
diff -ru a/src/forward.c b/src/forward.c
--- a/src/forward.c	2018-10-19 02:21:55.000000000 +0800
+++ b/src/forward.c	2018-10-20 00:01:17.631681086 +0800
@@ -155,11 +155,38 @@
       }
     else if (serv->flags & SERV_HAS_DOMAIN)
       {
-	unsigned int domainlen = strlen(serv->domain);
-	char *matchstart = qdomain + namelen - domainlen;
-	if (namelen >= domainlen &&
-	    hostname_isequal(matchstart, serv->domain) &&
-	    (domainlen == 0 || namelen == domainlen || *(matchstart-1) == '.' ))
+	unsigned int domainlen = matchlen;
+	int serverhit = 0;
+
+#ifdef HAVE_REGEX
+	if (serv->flags & SERV_IS_REGEX)
+	  {
+	    int captcount = 0;
+	    if (pcre_fullinfo(serv->regex, serv->pextra, PCRE_INFO_CAPTURECOUNT, &captcount) == 0)
+	      {
+		/* C99 dyn-array, or alloca must be used */
+		int ovect[(captcount + 1) * 3];
+		if (pcre_exec(serv->regex, serv->pextra, qdomain, namelen, 0, 0, ovect, (captcount + 1) * 3) > 0)
+		  {
+		    domainlen = (unsigned int) (ovect[1] - ovect[0]);
+		    if (domainlen >= matchlen)
+		      serverhit = 1;
+		  }
+	      }
+	  }
+	else
+#endif
+	  {
+	    char *matchstart;
+	    domainlen = strlen(serv->domain);
+	    matchstart = qdomain + namelen - domainlen;
+	    if (namelen >= domainlen &&
+	        hostname_isequal(matchstart, serv->domain) &&
+	        (domainlen == 0 || namelen == domainlen || *(matchstart-1) == '.' ))
+	       serverhit = 1;
+	  }
+
+	if (serverhit)
 	  {
 	    if ((serv->flags & SERV_NO_REBIND) && norebind)	
 	      *norebind = 1;
@@ -186,6 +213,11 @@
 		if (domainlen >= matchlen)
 		  {
 		    *type = serv->flags & (SERV_HAS_DOMAIN | SERV_USE_RESOLV | SERV_NO_REBIND | SERV_DO_DNSSEC);
+#ifdef HAVE_REGEX
+		    if (serv->flags & SERV_IS_REGEX)
+				*domain = qdomain;
+		    else
+#endif
 		    *domain = serv->domain;
 		    matchlen = domainlen;
 		    if (serv->flags & SERV_NO_ADDR)
@@ -250,6 +282,27 @@
   return  flags;
 }
 
+static int match_domain_for_forward(char *domain, struct server *serv)
+{
+  int ret_val = 0;
+  if(serv->flags & SERV_IS_REGEX)
+    {
+#ifdef HAVE_REGEX
+      int captcount = 0;
+      if (pcre_fullinfo(serv->regex, serv->pextra, PCRE_INFO_CAPTURECOUNT, &captcount) == 0)
+	{
+	  /* C99 dyn-array, or alloca must be used */
+	  int ovect[(captcount + 1) * 3];
+	  ret_val = pcre_exec(serv->regex, serv->pextra, domain,
+	                      strlen(domain), 0, 0, ovect, (captcount + 1) * 3) > 0;
+	}
+#endif
+    }
+  else
+    ret_val = hostname_isequal(domain, serv->domain);
+  return ret_val;
+}
+
 static int forward_query(int udpfd, union mysockaddr *udpaddr,
 			 struct all_addr *dst_addr, unsigned int dst_iface,
 			 struct dns_header *header, size_t plen, time_t now, 
@@ -328,6 +381,11 @@
 #endif
 
       /* retry on existing query, send to all available servers  */
+#ifdef HAVE_REGEX
+      if(forward->sentto->flags & SERV_IS_REGEX)
+          domain = daemon->namebuff;
+      else
+#endif
       domain = forward->sentto->domain;
       forward->sentto->failed_queries++;
       if (!option_bool(OPT_ORDER))
@@ -465,7 +523,7 @@
 	     must be NULL also. */
 	  
 	  if (type == (start->flags & SERV_TYPE) &&
-	      (type != SERV_HAS_DOMAIN || hostname_isequal(domain, start->domain)) &&
+	      (type != SERV_HAS_DOMAIN || match_domain_for_forward(domain, start)) &&
 	      !(start->flags & (SERV_LITERAL_ADDRESS | SERV_LOOP)))
 	    {
 	      int fd;
diff -ru a/src/network.c b/src/network.c
--- a/src/network.c	2018-10-19 02:21:55.000000000 +0800
+++ b/src/network.c	2018-10-20 00:03:18.728424816 +0800
@@ -1553,7 +1553,7 @@
 	    serv->sfd->used = 1;
 	}
       
-      if (!(serv->flags & SERV_NO_REBIND) && !(serv->flags & SERV_LITERAL_ADDRESS))
+      if (!(serv->flags & (SERV_NO_REBIND | SERV_IS_REGEX)) && !(serv->flags & SERV_LITERAL_ADDRESS))
 	{
 	  if (++count > SERVERS_LOGGED)
 	    continue;
diff -ru a/src/option.c b/src/option.c
--- a/src/option.c	2018-10-19 02:21:55.000000000 +0800
+++ b/src/option.c	2018-10-20 00:07:35.227269605 +0800
@@ -2417,6 +2417,12 @@
 	    while (rebind || (end = split_chr(arg, '/')))
 	      {
 		char *domain = NULL;
+		char *regex = NULL;
+		char *real_end = arg + strlen(arg);
+		if (*arg == ':' && *(real_end - 1) == ':'){
+			*(real_end - 1) = '\0';
+			regex = arg + 1;
+		}else{
 		/* elide leading dots - they are implied in the search algorithm */
 		while (*arg == '.') arg++;
 		/* # matches everything and becomes a zero length domain string */
@@ -2424,12 +2430,27 @@
 		  domain = "";
 		else if (strlen (arg) != 0 && !(domain = canonicalise_opt(arg)))
 		  ret_err(gen_err);
+		}
 		serv = opt_malloc(sizeof(struct server));
 		memset(serv, 0, sizeof(struct server));
 		serv->next = newlist;
 		newlist = serv;
 		serv->domain = domain;
-		serv->flags = domain ? SERV_HAS_DOMAIN : SERV_FOR_NODOTS;
+		serv->flags = domain || regex ? SERV_HAS_DOMAIN : SERV_FOR_NODOTS;
+		if (regex){
+#ifdef HAVE_REGEX
+			const char *error;
+			int erroff;
+			serv->regex = pcre_compile(regex, 0, &error, &erroff, NULL);
+
+			if (!serv->regex)
+				ret_err(error);
+			serv->flags |= SERV_IS_REGEX;
+			serv->pextra = pcre_study(serv->regex, 0, &error);
+#else
+			ret_err("Using a regex while server was configured without regex support!");
+#endif
+		}
 		arg = end;
 		if (rebind)
 		  break;
diff -ru a/src/rfc1035.c b/src/rfc1035.c
--- a/src/rfc1035.c	2018-10-19 02:21:55.000000000 +0800
+++ b/src/rfc1035.c	2018-10-20 00:09:33.191004797 +0800
@@ -1538,6 +1538,8 @@
 
 		      if ((serv->flags & (SERV_HAS_DOMAIN | SERV_NO_ADDR)) != SERV_HAS_DOMAIN)
 		        continue;
+			  
+			  if (NULL == serv->domain) continue;
 
 		      domainlen = strlen(serv->domain);
 		      if (domainlen == 0 || domainlen > namelen)
diff -ru a/src/util.c b/src/util.c
--- a/src/util.c	2018-10-19 02:21:55.000000000 +0800
+++ b/src/util.c	2018-10-20 00:10:58.902515288 +0800
@@ -349,7 +349,7 @@
 int hostname_isequal(const char *a, const char *b)
 {
   unsigned int c1, c2;
-  
+  if(NULL == a || NULL == b) return (NULL == a && NULL == b);  
   do {
     c1 = (unsigned char) *a++;
     c2 = (unsigned char) *b++;
